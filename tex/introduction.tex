\section{Introduction}
Programming languages are ubiquitous tools in today's technological development scene. These tools have been present in it for many decades, with the first high-level implementation being created in 1954 - the Fortran language. \cite{howlett1980history} With this historical presence, it is possible to see that popular programming languages evolve over time. \cite{pirkelbauer2010source} This evolution occurs often due to changes in hardware or software constraints or even due to a desire to simplify, modify or extend the use of the tool. As these languages evolve, new solutions are created for problems which had no previously implemented solution. In this sense, the time before the adoption of a new version or modern elements of a language contains many examples of the use of idioms and workarounds \cite{pirkelbauer2010source}, which are solutions to these problems, but applied directly to software written in a language without native support to such a solution. These techniques are often associated with execution problems and code maintenance difficulties. \cite{pirkelbauer2010source}

In an effort to maintain or update a software application, a developer can choose from a number of options to accomplish this task. One of the most common practices is called refactoring, in which changes are made to improve the program's design, while keeping its behavior the same as before. \cite{pirkelbauer2010source} The developer can also choose to adapt the application so that it runs in a more recent version of the original programming language, or use features that are present in the same version but were not previously in use. This type of practice usually adapts code patterns, data structures and other characteristics that are at a lower level of abstraction, transforming them into code at a higher level of abstraction that is more concise and secure. \cite{pirkelbauer2010source} In addition, the adapted code contains information that is better exposed to the programmer and compiler, which would otherwise be very involved in other parts of the code. \cite{pirkelbauer2010source} This practice is called source code rejuvenation.

The C++ programming language is no stranger to such practice. Having existed and being employed for multiple decades, the language has evolved into much more than it originally was. From its original conception of being an extension of C, to its first standardizations in the late 1990's and early 2000's, to its present cycle of 3-year releases, the language has been adapted to needs of various kinds and allowed developers to build even more onto itself as time allowed it and demand incetivized it to. This being the case, the body of code written in early versions of this programming language has no short of examples of idioms and workarounds, especially if those pieces of software are still in use currently. The language's long history of widespread usage and, more recently, increased frequency of new releases, has unavoidably made discussions regarding development and maintenance contain some sort of rejuvenation topics.

Beyond the C++ language itself, there is also the Boost community, who contributed to the language's first and subsequent standardizations. This community consists of voluntary developers who build and maintain C++ libraries that provide extended functionalities to the language. These libraries were important to the creation of the first C++ standard (C++98) and also contributed to the first major release since: C++11. For example, functionalities such as the auto keyword and smart pointers have their origins in Boost libraries\cite{schaling2014boost}. Its contributions to more recent standards have not been as representative as the ones that came before, but they still were helpful for later releases. The community is still active to the present day, developing and maintaining the Boost set of libraries.

Being an entity that has been present since the early times of the C++ language and has had such an important role in its development, this community is bound to have lots of development discussion spanning many years, and consequently many different C++ standards. This is an area of interest regarding source code rejuventaion research, as there may be many things to be learned from how the developers at Boost discussed rejuvenation over its existence.

This document aims to present an effort to apply data mining, natural language processing and thematic analysis techniques to better understand the nature of discussions related to C++ source code rejuvenation, in particular, how it is present in the Boost mailing list. With this effort, it is expected that the results may reveal interesting insights into the overall presence of source code rejuvenation discussions, as well as into the pains that developers face when discussing and/or implementing said changes. These insights would be valuable to incentivize, inform and align further research on the topic and development relating to the rejuvenation issue. This effort also has the added benefit of expanding the known body of collected discussions regarding the source code rejuvenation subject.



%% BACKGROUND AND RELATED WORK ------------------------
